# 系统接口详解

MeowOS核心接口的完整说明和使用示例。

## 系统核心接口

### SystemService接口

系统服务的主要接口，负责应用管理、窗口控制、主题切换等核心功能。

#### 接口定义

```typescript
interface ISystemService {
  // 应用管理
  listApps(): AppManifest[]
  openApp(appId: string, options?: Partial<WindowState>): Promise<WindowState | null>
  closeApp(appId: string): boolean
  getAppById(appId: string): AppManifest | undefined
  addCustomApp(manifest: AppManifest): Promise<void>
  removeCustomApp(appId: string): Promise<void>
  
  // 窗口管理
  getWindows(): WindowState[]
  getWindowById(windowId: string): WindowState | undefined
  focusWindow(windowId: string): void
  minimizeWindow(windowId: string): void
  maximizeWindow(windowId: string): void
  closeWindow(windowId: string): void
  updateWindowState(windowId: string, updates: Partial<WindowState>): void
  
  // 主题管理
  setTheme(themeId: string): Promise<void>
  applyTheme(themeId: string): void
  getThemes(): ThemeDefinition[]
  addCustomTheme(theme: ThemeDefinition): Promise<void>
  
  // 配置管理
  getConfig(): SystemConfig
  setUserConfig(config: UserConfig): void
  getUserConfig(): UserConfig
  resetConfig(): void
  
  // 系统状态
  getSystemInfo(): SystemInfo
  getPerformanceStats(): PerformanceStats
}
```

#### 实际使用示例

```typescript
import { system } from '@/core/api'

// 获取所有应用
const apps = system.listApps()
console.log('系统应用:', apps.map(app => app.name))

// 打开应用并获取窗口引用
const window = await system.openApp('text-reader', {
  title: '我的文档',
  size: { width: 800, height: 600 }
})

if (window) {
  console.log('窗口已创建:', window.id)
}

// 管理窗口状态
const windows = system.getWindows()
windows.forEach(win => {
  if (win.isMinimized) {
    system.focusWindow(win.id)
  }
})

// 切换主题
await system.setTheme('dark')
```

### DocumentSystem接口

文档系统接口，提供文档扫描、管理和访问功能。

#### 接口定义

```typescript
interface IDocumentSystem {
  // 文档获取
  getDocuments(path?: string): DocumentItem[]
  getDocumentContent(path: string): Promise<string>
  getDocumentByPath(path: string): DocumentItem | undefined
  
  // 搜索功能
  searchDocuments(query: string): DocumentItem[]
  searchDocumentContent(query: string): Promise<SearchResult[]>
  
  // 导航辅助
  getBreadcrumbs(path: string): BreadcrumbItem[]
  getParentDirectory(path: string): string
  getDirectoryTree(): DirectoryNode
  
  // 统计信息
  getStats(): DocumentStats
  getRecentDocuments(limit?: number): DocumentItem[]
  getRecommendedDocuments(): DocumentItem[]
  
  // 系统状态
  isLoaded(): boolean
  refresh(): Promise<void>
  
  // 事件监听
  onDocumentAdded(callback: (doc: DocumentItem) => void): void
  onDocumentUpdated(callback: (doc: DocumentItem) => void): void
  onDocumentRemoved(callback: (path: string) => void): void
}
```

#### 实际使用示例

```typescript
import { documentSystem } from '@/core/api'

// 等待系统加载完成
const waitForDocuments = async () => {
  while (!documentSystem.isLoaded()) {
    await new Promise(resolve => setTimeout(resolve, 100))
  }
}

await waitForDocuments()

// 获取教程目录下的文档
const tutorials = documentSystem.getDocuments('/教程')
console.log('教程文档:', tutorials)

// 搜索包含"API"的文档
const apiDocs = documentSystem.searchDocuments('API')
console.log('API相关文档:', apiDocs)

// 获取文档内容
const docContent = await documentSystem.getDocumentContent('/教程/开发指南.md')
console.log('文档内容长度:', docContent.length)

// 获取导航面包屑
const breadcrumbs = documentSystem.getBreadcrumbs('/教程/应用开发/基础教程.md')
console.log('导航路径:', breadcrumbs.map(b => b.name).join(' > '))
```

### StorageService接口

存储服务接口，提供数据持久化功能。

#### 接口定义

```typescript
interface IStorageService {
  // 基础存储
  set(key: string, value: any, useIDB?: boolean): Promise<void>
  get(key: string, useIDB?: boolean): Promise<any>
  remove(key: string, useIDB?: boolean): Promise<void>
  clear(useIDB?: boolean): Promise<void>
  keys(useIDB?: boolean): Promise<string[]>
  
  // 应用专用存储
  setAppSetting(appId: string, key: string, value: any): Promise<void>
  getAppSetting(appId: string, key: string): Promise<any>
  removeAppSetting(appId: string, key: string): Promise<void>
  clearAppData(appId: string): Promise<void>
  getAppKeys(appId: string): Promise<string[]>
  
  // 系统设置存储
  setSystemSetting(key: string, value: any): Promise<void>
  getSystemSetting(key: string): Promise<any>
  removeSystemSetting(key: string): Promise<void>
  
  // 存储统计
  getStorageStats(): Promise<StorageStats>
  getUsage(): Promise<StorageUsage>
  
  // 数据迁移
  exportData(): Promise<ExportData>
  importData(data: ExportData): Promise<void>
  
  // 事件监听
  onStorageChange(callback: (event: StorageChangeEvent) => void): void
}
```

#### 实际使用示例

```typescript
import { storage } from '@/core/api'

// 应用设置管理
class MyAppSettings {
  private readonly APP_ID = 'my-text-editor'
  
  async saveSettings(settings: any) {
    await storage.setAppSetting(this.APP_ID, 'settings', settings)
  }
  
  async loadSettings() {
    return await storage.getAppSetting(this.APP_ID, 'settings') || {
      fontSize: 14,
      theme: 'default',
      autoSave: true
    }
  }
  
  async saveDocument(docId: string, content: string) {
    await storage.setAppSetting(this.APP_ID, `doc_${docId}`, {
      content,
      lastModified: Date.now()
    })
  }
  
  async loadDocument(docId: string) {
    return await storage.getAppSetting(this.APP_ID, `doc_${docId}`)
  }
  
  async getDocumentList() {
    const keys = await storage.getAppKeys(this.APP_ID)
    return keys.filter(key => key.startsWith('doc_'))
  }
}

// 系统级配置
const saveSystemConfig = async (config: any) => {
  await storage.setSystemSetting('systemConfig', config)
}

const loadSystemConfig = async () => {
  return await storage.getSystemSetting('systemConfig')
}

// 存储使用情况检查
const checkStorageUsage = async () => {
  const usage = await storage.getUsage()
  console.log('存储使用情况:', usage)
  
  if (usage.percentage > 80) {
    console.warn('存储空间不足')
  }
}
```

### EventBus接口

事件总线接口，用于组件间通信。

#### 接口定义

```typescript
interface IEventBus {
  // 基础事件方法
  on(event: string, callback: Function): void
  off(event: string, callback?: Function): void
  emit(event: string, ...args: any[]): void
  once(event: string, callback: Function): void
  
  // 事件管理
  hasListeners(event: string): boolean
  getListenerCount(event: string): number
  removeAllListeners(event?: string): void
  
  // 事件命名空间
  namespace(ns: string): IEventBus
  
  // 异步事件
  emitAsync(event: string, ...args: any[]): Promise<any[]>
  
  // 事件拦截
  intercept(event: string, interceptor: EventInterceptor): void
  removeInterceptor(event: string, interceptor: EventInterceptor): void
}
```

#### 实际使用示例

```typescript
import { eventBus, SystemEvents } from '@/core/api'

// 监听系统事件
eventBus.on(SystemEvents.ThemeChanged, (themeId: string) => {
  console.log('主题切换到:', themeId)
  updateAppTheme(themeId)
})

eventBus.on(SystemEvents.AppOpened, (app: AppManifest) => {
  console.log('应用已打开:', app.name)
  updateTaskbar()
})

// 自定义事件通信
class AppCommunication {
  private readonly APP_EVENTS = {
    DATA_SHARED: 'app:dataShared',
    USER_ACTION: 'app:userAction',
    STATE_CHANGED: 'app:stateChanged'
  }
  
  // 发布数据共享事件
  shareData(data: any) {
    eventBus.emit(this.APP_EVENTS.DATA_SHARED, {
      source: 'my-app',
      timestamp: Date.now(),
      data
    })
  }
  
  // 监听其他应用的数据
  listenForSharedData(callback: (data: any) => void) {
    eventBus.on(this.APP_EVENTS.DATA_SHARED, (event) => {
      if (event.source !== 'my-app') {
        callback(event.data)
      }
    })
  }
  
  // 异步事件处理
  async broadcastUserAction(action: string) {
    const responses = await eventBus.emitAsync(this.APP_EVENTS.USER_ACTION, {
      action,
      timestamp: Date.now()
    })
    
    console.log('收到响应:', responses.length)
    return responses
  }
}

// 事件命名空间使用
const musicEvents = eventBus.namespace('music')
musicEvents.on('play', (track) => console.log('播放:', track))
musicEvents.on('pause', () => console.log('暂停'))

// 事件拦截器示例
eventBus.intercept('user:action', (event, next) => {
  // 记录用户行为
  console.log('用户操作:', event)
  
  // 可以修改事件或阻止传播
  if (event.type === 'dangerous') {
    console.warn('危险操作被拦截')
    return false // 阻止事件传播
  }
  
  return next(event) // 继续传播
})
```

### SystemAudio接口

音频系统接口，提供音频播放和管理功能。

#### 接口定义

```typescript
interface ISystemAudio {
  // 基础播放控制
  play(): Promise<void>
  pause(): void
  stop(): void
  togglePlayPause(): void
  
  // 音量控制
  setVolume(volume: number): void
  getVolume(): number
  toggleMute(): void
  isMuted(): boolean
  
  // 播放列表管理
  loadPlaylist(tracks: AudioTrack[]): void
  getCurrentTrack(): AudioTrack | null
  nextTrack(): void
  previousTrack(): void
  seekToTrack(index: number): void
  
  // 音效播放
  playSound(filePath: string, options?: SoundOptions): Promise<string>
  stopSound(soundId?: string): void
  playSystemSound(soundType: SystemSoundType): void
  
  // 播放状态
  isPlaying(): boolean
  getCurrentTime(): number
  getDuration(): number
  getProgress(): number
  seekTo(time: number): void
  
  // 事件监听
  onTrackChanged(callback: (track: AudioTrack) => void): void
  onPlayStateChanged(callback: (isPlaying: boolean) => void): void
  onVolumeChanged(callback: (volume: number) => void): void
  onTimeUpdate(callback: (time: number, duration: number) => void): void
}
```

#### 实际使用示例

```typescript
import { systemAudio } from '@/core/api'

// 音乐播放器示例
class MusicPlayer {
  constructor() {
    this.setupEventListeners()
  }
  
  async loadAndPlay(tracks: AudioTrack[]) {
    systemAudio.loadPlaylist(tracks)
    await systemAudio.play()
  }
  
  private setupEventListeners() {
    systemAudio.onTrackChanged((track) => {
      console.log('当前播放:', track.title)
      this.updateUI(track)
    })
    
    systemAudio.onPlayStateChanged((isPlaying) => {
      console.log('播放状态:', isPlaying ? '播放中' : '已暂停')
      this.updatePlayButton(isPlaying)
    })
    
    systemAudio.onTimeUpdate((time, duration) => {
      this.updateProgress(time, duration)
    })
  }
  
  // 播放系统提示音
  playNotificationSound() {
    systemAudio.playSystemSound('notification')
  }
  
  // 播放自定义音效
  async playClickSound() {
    await systemAudio.playSound('/audio/click.mp3', {
      volume: 0.5,
      duration: 200
    })
  }
}

// 音频可视化示例
class AudioVisualizer {
  private audioContext: AudioContext
  private analyser: AnalyserNode
  
  async init() {
    this.audioContext = new AudioContext()
    this.analyser = this.audioContext.createAnalyser()
    
    // 连接到系统音频
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
    const source = this.audioContext.createMediaStreamSource(stream)
    source.connect(this.analyser)
    
    this.startVisualization()
  }
  
  private startVisualization() {
    const dataArray = new Uint8Array(this.analyser.frequencyBinCount)
    
    const animate = () => {
      this.analyser.getByteFrequencyData(dataArray)
      this.drawSpectrum(dataArray)
      requestAnimationFrame(animate)
    }
    
    animate()
  }
  
  private drawSpectrum(data: Uint8Array) {
    // 绘制频谱可视化
  }
}
```

## 接口扩展和自定义

### 创建自定义服务接口

```typescript
// 定义自定义服务接口
interface INotificationService {
  show(message: string, options?: NotificationOptions): Promise<string>
  hide(id: string): void
  clear(): void
  getAll(): Notification[]
}

// 实现服务
class NotificationService implements INotificationService {
  private notifications: Map<string, Notification> = new Map()
  
  async show(message: string, options: NotificationOptions = {}): Promise<string> {
    const id = `notification_${Date.now()}`
    const notification = {
      id,
      message,
      type: options.type || 'info',
      duration: options.duration || 3000,
      timestamp: Date.now()
    }
    
    this.notifications.set(id, notification)
    
    // 显示通知
    this.displayNotification(notification)
    
    // 自动隐藏
    if (notification.duration > 0) {
      setTimeout(() => this.hide(id), notification.duration)
    }
    
    return id
  }
  
  hide(id: string): void {
    this.notifications.delete(id)
    this.removeNotificationElement(id)
  }
  
  clear(): void {
    this.notifications.clear()
    this.removeAllNotificationElements()
  }
  
  getAll(): Notification[] {
    return Array.from(this.notifications.values())
  }
  
  private displayNotification(notification: Notification) {
    // 创建通知元素并显示
  }
  
  private removeNotificationElement(id: string) {
    // 移除通知元素
  }
  
  private removeAllNotificationElements() {
    // 移除所有通知元素
  }
}

// 注册到全局API
export const notifications = new NotificationService()
```

### 接口装饰器

```typescript
// 创建API调用装饰器
function apiCall(target: any, propertyName: string, descriptor: PropertyDescriptor) {
  const method = descriptor.value
  
  descriptor.value = async function (...args: any[]) {
    const startTime = performance.now()
    
    try {
      console.log(`API调用: ${propertyName}`, args)
      const result = await method.apply(this, args)
      
      const duration = performance.now() - startTime
      console.log(`API完成: ${propertyName} (${duration.toFixed(2)}ms)`)
      
      return result
    } catch (error) {
      console.error(`API错误: ${propertyName}`, error)
      throw error
    }
  }
  
  return descriptor
}

// 使用装饰器
class EnhancedSystemService {
  @apiCall
  async openApp(appId: string): Promise<WindowState | null> {
    // 实现逻辑
    return null
  }
  
  @apiCall
  async setTheme(themeId: string): Promise<void> {
    // 实现逻辑
  }
}
```

### 接口代理

```typescript
// 创建API代理，添加额外功能
const createApiProxy = <T extends object>(api: T): T => {
  return new Proxy(api, {
    get(target, prop, receiver) {
      const originalValue = Reflect.get(target, prop, receiver)
      
      if (typeof originalValue === 'function') {
        return function (...args: any[]) {
          // 权限检查
          if (!hasPermission(prop as string)) {
            throw new Error(`没有权限调用 ${prop as string}`)
          }
          
          // 速率限制
          if (isRateLimited(prop as string)) {
            throw new Error(`调用 ${prop as string} 过于频繁`)
          }
          
          // 执行原始方法
          return originalValue.apply(this, args)
        }
      }
      
      return originalValue
    }
  })
}

// 使用代理
const secureSystem = createApiProxy(system)
```

## 接口版本管理

### 版本兼容性处理

```typescript
interface ApiVersion {
  version: string
  deprecated?: boolean
  removedIn?: string
  replacement?: string
}

class VersionedApi {
  private version = '1.0.0'
  
  @deprecated('2.0.0', 'use newMethod instead')
  oldMethod() {
    console.warn('oldMethod is deprecated, use newMethod instead')
    return this.newMethod()
  }
  
  newMethod() {
    return 'new implementation'
  }
}

function deprecated(removedIn: string, replacement: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value
    
    descriptor.value = function (...args: any[]) {
      console.warn(
        `方法 ${propertyName} 已废弃，将在版本 ${removedIn} 中移除。` +
        `请使用 ${replacement} 替代。`
      )
      return method.apply(this, args)
    }
    
    return descriptor
  }
}
```

这份接口详解文档基于MeowOS的实际接口实现编写，提供了完整的接口说明和实用示例。
