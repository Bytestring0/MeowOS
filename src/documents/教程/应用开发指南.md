# 应用开发指南

详细的应用开发流程和窗口适配指南。

## 应用架构

### 基础应用结构

MeowOS应用由三部分组成：

1. **Vue组件**：应用的界面实现
2. **TypeScript类**：应用的业务逻辑 
3. **manifest.json**：应用配置清单

### 项目结构

```
src/system-apps/my-app/
├── manifest.json        # 应用配置
├── MyApp.vue           # 界面组件
└── MyApp.ts            # 业务逻辑
```

## 创建新应用

### 1. 创建应用目录

在`src/system-apps/`下创建应用文件夹：

```
mkdir src/system-apps/my-calculator
cd src/system-apps/my-calculator
```

### 2. 编写manifest.json

```json
{
  "id": "my-calculator",
  "name": "计算器",
  "description": "简单的计算器应用",
  "version": "1.0.0",
  "icon": "icons/calculator.svg",
  "type": "app",
  "entry": "MyCalculator",
  "singleInstance": true,
  "showOnDesktop": true,
  "permissions": ["storage"]
}
```

配置说明：
- `id`: 唯一标识，建议使用kebab-case
- `singleInstance`: 是否单例模式，推荐设为true
- `entry`: 组件名，必须与Vue组件的name一致
- `permissions`: 权限列表，可选值：storage、audio、network

### 3. 创建Vue组件

**MyCalculator.vue:**

```vue
<template>
  <div class="calculator">
    <div class="display">{{ display }}</div>
    <div class="buttons">
      <button v-for="btn in buttons" :key="btn"
              @click="handleInput(btn)"
              :class="getButtonClass(btn)">
        {{ btn }}
      </button>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, onMounted, onUnmounted } from 'vue'
import { MyCalculatorApp } from './MyCalculator'

export default defineComponent({
  name: 'MyCalculator',
  setup() {
    const calculator = new MyCalculatorApp()
    const display = ref('0')
    
    const buttons = [
      'C', '±', '%', '÷',
      '7', '8', '9', '×',
      '4', '5', '6', '-',
      '1', '2', '3', '+',
      '0', '.', '='
    ]
    
    const handleInput = (input: string) => {
      const result = calculator.handleInput(input)
      display.value = result
    }
    
    const getButtonClass = (btn: string) => {
      if (['C', '±', '%'].includes(btn)) return 'btn-function'
      if (['÷', '×', '-', '+', '='].includes(btn)) return 'btn-operator'
      return 'btn-number'
    }
    
    // 键盘支持
    const handleKeydown = (event: KeyboardEvent) => {
      const keyMap: Record<string, string> = {
        'Enter': '=',
        'Escape': 'C',
        '/': '÷',
        '*': '×'
      }
      
      const key = keyMap[event.key] || event.key
      if (buttons.includes(key)) {
        handleInput(key)
      }
    }
    
    onMounted(() => {
      calculator.init()
      window.addEventListener('keydown', handleKeydown)
    })
    
    onUnmounted(() => {
      window.removeEventListener('keydown', handleKeydown)
      calculator.destroy()
    })
    
    return {
      display,
      buttons,
      handleInput,
      getButtonClass
    }
  }
})
</script>

<style scoped>
.calculator {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  background: var(--surface-color);
  border-radius: 8px;
  overflow: hidden;
}

.display {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  padding: 20px;
  font-size: 2rem;
  font-weight: 300;
  background: var(--surface-variant-color);
  color: var(--on-surface-color);
  min-height: 60px;
}

.buttons {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 1px;
  background: var(--outline-color);
}

button {
  height: 60px;
  border: none;
  background: var(--surface-color);
  color: var(--on-surface-color);
  font-size: 1.2rem;
  cursor: pointer;
  transition: background-color 0.2s;
}

button:hover {
  background: var(--surface-variant-color);
}

button:active {
  background: var(--primary-color);
  color: var(--on-primary-color);
}

.btn-function {
  background: var(--secondary-color);
  color: var(--on-secondary-color);
}

.btn-operator {
  background: var(--primary-color);
  color: var(--on-primary-color);
}

.btn-number:nth-child(17) {
  grid-column: span 2;
}
</style>
```

### 4. 创建业务逻辑类

**MyCalculator.ts:**

```typescript
import { storage, eventBus, SystemEvents } from '@/core/api'

export class MyCalculatorApp {
  private currentValue: number = 0
  private previousValue: number = 0
  private operator: string | null = null
  private waitingForNewValue: boolean = false
  private history: string[] = []

  constructor() {
    this.loadHistory()
  }

  async init() {
    // 监听主题变化
    eventBus.on(SystemEvents.ThemeChanged, this.onThemeChanged)
    
    // 恢复上次的计算状态
    const lastState = await storage.getAppSetting('my-calculator', 'lastState')
    if (lastState) {
      this.currentValue = lastState.currentValue || 0
      this.previousValue = lastState.previousValue || 0
      this.operator = lastState.operator || null
    }
  }

  destroy() {
    eventBus.off(SystemEvents.ThemeChanged, this.onThemeChanged)
    this.saveState()
  }

  handleInput(input: string): string {
    switch (input) {
      case 'C':
        return this.clear()
      case '±':
        return this.toggleSign()
      case '%':
        return this.percentage()
      case '=':
        return this.calculate()
      case '+':
      case '-':
      case '×':
      case '÷':
        return this.setOperator(input)
      case '.':
        return this.addDecimal()
      default:
        if (/^\d$/.test(input)) {
          return this.addDigit(input)
        }
        break
    }
    return this.getDisplayValue()
  }

  private clear(): string {
    this.currentValue = 0
    this.previousValue = 0
    this.operator = null
    this.waitingForNewValue = false
    return '0'
  }

  private toggleSign(): string {
    this.currentValue = -this.currentValue
    return this.getDisplayValue()
  }

  private percentage(): string {
    this.currentValue = this.currentValue / 100
    return this.getDisplayValue()
  }

  private addDigit(digit: string): string {
    if (this.waitingForNewValue) {
      this.currentValue = parseFloat(digit)
      this.waitingForNewValue = false
    } else {
      const current = this.getDisplayValue()
      this.currentValue = parseFloat(current === '0' ? digit : current + digit)
    }
    return this.getDisplayValue()
  }

  private addDecimal(): string {
    const current = this.getDisplayValue()
    if (current.indexOf('.') === -1) {
      return this.waitingForNewValue ? '0.' : current + '.'
    }
    return current
  }

  private setOperator(op: string): string {
    if (this.operator && !this.waitingForNewValue) {
      this.calculate()
    }
    
    this.previousValue = this.currentValue
    this.operator = op
    this.waitingForNewValue = true
    
    return this.getDisplayValue()
  }

  private calculate(): string {
    if (!this.operator || this.waitingForNewValue) {
      return this.getDisplayValue()
    }

    let result: number
    const prev = this.previousValue
    const current = this.currentValue

    switch (this.operator) {
      case '+':
        result = prev + current
        break
      case '-':
        result = prev - current
        break
      case '×':
        result = prev * current
        break
      case '÷':
        result = current !== 0 ? prev / current : 0
        break
      default:
        return this.getDisplayValue()
    }

    // 记录计算历史
    const expression = `${prev} ${this.operator} ${current} = ${result}`
    this.addToHistory(expression)

    this.currentValue = result
    this.operator = null
    this.waitingForNewValue = true

    return this.getDisplayValue()
  }

  private getDisplayValue(): string {
    const value = this.currentValue.toString()
    
    // 处理小数位数
    if (value.includes('.')) {
      const [integer, decimal] = value.split('.')
      if (decimal.length > 8) {
        return parseFloat(this.currentValue.toFixed(8)).toString()
      }
    }
    
    // 处理大数显示
    if (Math.abs(this.currentValue) >= 1e10) {
      return this.currentValue.toExponential(3)
    }
    
    return value
  }

  private async addToHistory(expression: string) {
    this.history.unshift(expression)
    if (this.history.length > 50) {
      this.history = this.history.slice(0, 50)
    }
    await storage.setAppSetting('my-calculator', 'history', this.history)
  }

  private async loadHistory() {
    const saved = await storage.getAppSetting('my-calculator', 'history')
    if (saved && Array.isArray(saved)) {
      this.history = saved
    }
  }

  private async saveState() {
    await storage.setAppSetting('my-calculator', 'lastState', {
      currentValue: this.currentValue,
      previousValue: this.previousValue,
      operator: this.operator
    })
  }

  private onThemeChanged = (theme: string) => {
    console.log(`计算器适配新主题: ${theme}`)
    // 这里可以添加主题适配逻辑
  }

  getHistory(): string[] {
    return [...this.history]
  }
}
```

## 窗口适配指南

### 父窗口通信

所有应用都运行在Window组件内，可以通过以下方式与父窗口通信：

#### 1. 窗口标题更新

```typescript
// 在应用内更新窗口标题
const updateTitle = (newTitle: string) => {
  const windowElement = document.querySelector('.window')
  if (windowElement) {
    const titleElement = windowElement.querySelector('.window-title')
    if (titleElement) {
      titleElement.textContent = newTitle
    }
  }
}
```

#### 2. 窗口状态监听

```typescript
// 监听窗口变化
onMounted(() => {
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === 'class') {
        const target = mutation.target as HTMLElement
        if (target.classList.contains('minimized')) {
          console.log('窗口被最小化')
        }
        if (target.classList.contains('maximized')) {
          console.log('窗口被最大化')
        }
      }
    })
  })
  
  const windowElement = document.querySelector('.window')
  if (windowElement) {
    observer.observe(windowElement, { attributes: true })
  }
  
  onUnmounted(() => {
    observer.disconnect()
  })
})
```

#### 3. 响应式布局

```vue
<template>
  <div class="app-container" :class="{ 
    'is-maximized': isMaximized,
    'is-mobile': isMobile 
  }">
    <!-- 应用内容 -->
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

const isMaximized = ref(false)
const isMobile = ref(false)

const updateLayout = () => {
  const windowElement = document.querySelector('.window')
  if (windowElement) {
    isMaximized.value = windowElement.classList.contains('maximized')
    const rect = windowElement.getBoundingClientRect()
    isMobile.value = rect.width < 600
  }
}

onMounted(() => {
  updateLayout()
  window.addEventListener('resize', updateLayout)
})

onUnmounted(() => {
  window.removeEventListener('resize', updateLayout)
})
</script>

<style scoped>
.app-container {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.is-maximized {
  padding: 20px;
}

.is-mobile {
  padding: 10px;
}

.is-mobile .toolbar {
  flex-wrap: wrap;
}
</style>
```

### 窗口生命周期

```typescript
export class MyApp {
  private isActive: boolean = true
  private windowObserver?: MutationObserver

  init() {
    this.setupWindowObserver()
  }

  destroy() {
    this.windowObserver?.disconnect()
  }

  private setupWindowObserver() {
    const windowElement = document.querySelector('.window')
    if (!windowElement) return

    this.windowObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'class') {
          const classList = (mutation.target as HTMLElement).classList
          
          if (classList.contains('minimized')) {
            this.onWindowMinimized()
          } else if (classList.contains('focused')) {
            this.onWindowFocused()
          } else {
            this.onWindowBlurred()
          }
        }
      })
    })

    this.windowObserver.observe(windowElement, { 
      attributes: true, 
      attributeFilter: ['class'] 
    })
  }

  private onWindowMinimized() {
    this.isActive = false
    // 暂停动画、停止计时器等
  }

  private onWindowFocused() {
    this.isActive = true
    // 恢复动画、重启计时器等
  }

  private onWindowBlurred() {
    this.isActive = false
    // 可选：减少资源使用
  }
}
```

## 应用注册

应用会被系统自动发现和注册，只需要：

1. 在`src/system-apps/`下创建应用目录
2. 包含有效的`manifest.json`
3. 系统会通过Vite的`import.meta.glob`自动扫描

### 自动发现机制

系统使用以下模式扫描应用：

```typescript
// system.ts中的自动发现代码
const manifestModules = import.meta.glob('/src/system-apps/*/manifest.json')
const componentModules = import.meta.glob('/src/system-apps/*/*.vue')
```

确保：
- 应用目录直接在`system-apps`下
- `manifest.json`在应用根目录
- Vue组件文件名与`entry`字段匹配

## 应用间通信

### 事件总线

```typescript
// 发送方
eventBus.emit('custom-message', { 
  from: 'my-calculator',
  data: '计算结果：42'
})

// 接收方
eventBus.on('custom-message', (message) => {
  console.log('收到消息:', message)
})
```

### 共享存储

```typescript
// 应用A：保存共享数据
await storage.set('shared-clipboard', {
  type: 'text',
  content: 'Hello World',
  timestamp: Date.now()
})

// 应用B：读取共享数据
const clipboardData = await storage.get('shared-clipboard')
if (clipboardData) {
  console.log('剪贴板内容:', clipboardData.content)
}
```

### LocalStorage桥接

```typescript
// 用于简单的应用间通信
const sendToApp = (targetApp: string, data: any) => {
  localStorage.setItem(`app-message-${targetApp}`, JSON.stringify({
    from: 'my-app',
    data,
    timestamp: Date.now()
  }))
  
  window.dispatchEvent(new CustomEvent('app-message', {
    detail: { target: targetApp, data }
  }))
}

// 监听来自其他应用的消息
window.addEventListener('app-message', (event) => {
  if (event.detail.target === 'my-app') {
    console.log('收到消息:', event.detail.data)
  }
})
```

## 性能优化

### 懒加载

```vue
<script setup>
import { defineAsyncComponent } from 'vue'

// 重型组件懒加载
const HeavyChart = defineAsyncComponent(() => 
  import('./components/HeavyChart.vue')
)

const showChart = ref(false)
</script>

<template>
  <div>
    <button @click="showChart = true">显示图表</button>
    <HeavyChart v-if="showChart" />
  </div>
</template>
```

### 内存管理

```typescript
export class MyApp {
  private timers: number[] = []
  private eventListeners: Array<{
    element: EventTarget;
    event: string;
    handler: EventListener;
  }> = []

  addTimer(callback: () => void, delay: number): number {
    const id = window.setTimeout(callback, delay)
    this.timers.push(id)
    return id
  }

  addEventListener(element: EventTarget, event: string, handler: EventListener) {
    element.addEventListener(event, handler)
    this.eventListeners.push({ element, event, handler })
  }

  destroy() {
    // 清理定时器
    this.timers.forEach(id => clearTimeout(id))
    this.timers = []
    
    // 清理事件监听器
    this.eventListeners.forEach(({ element, event, handler }) => {
      element.removeEventListener(event, handler)
    })
    this.eventListeners = []
  }
}
```

这份指南基于实际的MeowOS架构编写，所有示例代码都可以直接使用。
